
script = b'["--\\r\\n-- required packages for this script\\r\\n--\\r\\n\\r\\n-- Fix Support S7-300\xef\xbf\xbd\xef\xbf\xbd400 and S7-1200 and S7 Series Unknown Devices\\r\\n-- Last change 2014-11-14 plcscan.org\\r\\n--\\r\\nlocal bin \\u003d require \\"bin\\"\\r\\nlocal nmap \\u003d require \\"nmap\\"\\r\\nlocal shortport \\u003d require \\"shortport\\"\\r\\nlocal stdnse \\u003d require \\"stdnse\\"\\r\\nlocal string \\u003d require \\"string\\"\\r\\nlocal table \\u003d require \\"table\\"\\r\\n\\r\\ndescription \\u003d [[\\r\\nEnumerates Siemens S7 PLC Devices and collects their device information. This\\r\\nNSE is based off PLCScan that was developed by Positive Research and\\r\\nScadastrangelove (https://code.google.com/p/plcscan/). This script is meant to\\r\\nprovide the same functionality as PLCScan inside of Nmap. Some of the\\r\\ninformation that is collected by PLCScan was not ported over to this NSE, this\\r\\ninformation can be parsed out of the packets that are received.\\r\\n\\r\\nThanks to Positive Research, and Dmitry Efanov for creating PLCScan\\r\\n]]\\r\\n\\r\\nauthor \\u003d \\"Stephen Hilt (Digital Bond)\\"\\r\\nlicense \\u003d \\"Same as Nmap--See http://nmap.org/book/man-legal.html\\"\\r\\ncategories \\u003d {\\"discovery\\",\\"intrusive\\"}\\r\\n\\r\\n---\\r\\n-- @usage\\r\\n-- nmap -sS --script s7-discover.nse -p 102 \\u003chost/s\\u003e\\r\\n--\\r\\n-- @output\\r\\n--102/tcp open  Siemens S7 315 PLC\\r\\n--| s7-discover:\\r\\n--|   Basic Hardware: 6ES7 315-2AG10-0AB0\\r\\n--|   System Name: SIMATIC 300(1)\\r\\n--|   Copyright: Original Siemens Equipment\\r\\n--|   Version: 2.6.9\\r\\n--|   Module Type: CPU 315-2 DP\\r\\n--|   Module: 6ES7 315-2AG10-0AB0\\r\\n--|_  Serial Number: S C-X4U421302009\\r\\n--\\r\\n-- @output\\r\\n--102/tcp open  Siemens S7 1200 PLC\\r\\n-- s7-enumerate:\\r\\n--    Module: 6ES7 214-1AE30-0XB0\\r\\n--    Basic Hardware: 6ES7 214-1AE30-0XB0\\r\\n--    Version: 2.2.0\\r\\n--\\r\\n-- @xmloutput\\r\\n--\\u003celem key\\u003d\\"Basic Hardware\\"\\u003e6ES7 315-2AG10-0AB0\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"System Name\\"\\u003eSIMATIC 300(1)\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Copyright\\"\\u003eOriginal Siemens Equipment\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Version\\"\\u003e2.6.9\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Object Name\\"\\u003eSimpleServer\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Module Type\\"\\u003eCPU 315-2 DP\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Module\\"\\u003e6ES7 315-2AG10-0AB0\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Serial Number\\"\\u003eS C-X4U421302009\\u003c/elem\\u003e\\r\\n--\\u003celm key\\u003d\\"Plant Identification\\"\\u003e\\u003c/elem\\u003e\\r\\n\\r\\n\\r\\n-- port rule for devices running on TCP/102\\r\\nportrule \\u003d shortport.port_or_service(102, \\"iso-tsap\\", \\"tcp\\")\\r\\n\\r\\n---\\r\\n-- Function to send and receive the S7COMM Packet\\r\\n--\\r\\n-- First argument is the socket that was created inside of the main Action\\r\\n-- this will be utilized to send and receive the packets from the host.\\r\\n-- the second argument is the query to be sent, this is passed in and is created\\r\\n-- inside of the main action.\\r\\n-- @param socket the socket that was created in Action.\\r\\n-- @param query the specific query that you want to send/receive on.\\r\\nfunction send_receive(socket, query)\\r\\n  local sendstatus, senderr \\u003d socket:send(query)\\r\\n  if(sendstatus \\u003d\\u003d false) then\\r\\n    return \\"Error Sending S7COMM\\"\\r\\n  end\\r\\n  -- receive response\\r\\n  local rcvstatus,response \\u003d socket:receive()\\r\\n  if(rcvstatus \\u003d\\u003d false) then\\r\\n    return \\"Error Reading S7COMM\\"\\r\\n  end\\r\\n  return response\\r\\nend\\r\\n\\r\\n---\\r\\n-- Function to parse the first SZL Request response that was received from the S7 PLCC\\r\\n--\\r\\n-- First argument is the socket that was created inside of the main Action\\r\\n-- this will be utilized to send and receive the packets from the host.\\r\\n-- the second argument is the query to be sent, this is passed in and is created\\r\\n-- inside of the main action.\\r\\n-- @param response Packet response that was received from S7 host.\\r\\n-- @param host The host hat was passed in via Nmap, this is to change output of host/port\\r\\n-- @param port The port that was passed in via Nmap, this is to change output of host/port\\r\\n-- @param output Table used for output for return to Nmap\\r\\nfunction parse_response(response, host, port, output)\\r\\n  -- unpack the protocol ID\\r\\n  local pos, value \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n  -- unpack the second byte of the SZL-ID\\r\\n  local pos, szl_id \\u003d bin.unpack(\\"C\\", response, 31)\\r\\n  -- set the offset to 0\\r\\n  local offset \\u003d 0\\r\\n  -- if the protocol ID is 0x32\\r\\n  if (value \\u003d\\u003d 0x32) then\\r\\n    local pos\\r\\n    -- unpack the module information\\r\\n    pos, output[\\"Module\\"] \\u003d bin.unpack(\\"z\\", response, 44)\\r\\n    -- unpack the basic hardware information\\r\\n    pos, output[\\"Basic Hardware\\"] \\u003d bin.unpack(\\"z\\", response, 72)\\r\\n    -- set version number to 0\\r\\n    local version \\u003d 0\\r\\n    -- parse version number\\r\\n    local pos, char1,char2,char3 \\u003d bin.unpack(\\"CCC\\", response, 123)\\r\\n    -- concatenate string, or if string is nil make version number 0.0\\r\\n    output[\\"Version\\"] \\u003d table.concat({char1 or \\"0.0\\", char2, char3}, \\".\\")\\r\\n    -- return the output table\\r\\n    return output\\r\\n  else\\r\\n    output \\u003d DescFlag(S7DescFlag)\\r\\n\\treturn output\\r\\n  end\\r\\nend\\r\\n\\r\\n---\\r\\n-- Function to parse the second SZL Request response that was received from the S7 PLC\\r\\n--\\r\\n-- First argument is the socket that was created inside of the main Action\\r\\n-- this will be utilized to send and receive the packets from the host.\\r\\n-- the second argument is the query to be sent, this is passed in and is created\\r\\n-- inside of the main action.\\r\\n-- @param response Packet response that was received from S7 host.\\r\\n-- @param output Table used for output for return to Nmap\\r\\nfunction second_parse_response(response, output)\\r\\n  local offset \\u003d 0\\r\\n  -- unpack the protocol ID\\r\\n  local pos, value \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n  -- unpack the second byte of the SZL-ID\\r\\n  local pos, szl_id \\u003d bin.unpack(\\"C\\", response, 31)\\r\\n  -- if the protocol ID is 0x32\\r\\n  if (value \\u003d\\u003d 0x32) then\\r\\n    -- if the szl-ID is not 0x1c\\r\\n    if( szl_id ~\\u003d 0x1c ) then\\r\\n      -- change offset to 4, this is where most ov valid PLCs will fall\\r\\n      offset \\u003d 4\\r\\n    end\\r\\n    -- parse system name\\r\\n    pos, output[\\"System Name\\"] \\u003d bin.unpack(\\"z\\", response, 40 + offset)\\r\\n    -- parse module type\\r\\n    pos, output[\\"Module Type\\"] \\u003d bin.unpack(\\"z\\", response, 74 + offset)\\r\\n    -- parse serial number\\r\\n    pos, output[\\"Serial Number\\"] \\u003d bin.unpack(\\"z\\", response, 176 + offset)\\r\\n    -- parse plant identification\\r\\n    pos, output[\\"Plant Identification\\"] \\u003d bin.unpack(\\"z\\", response, 108 + offset)\\r\\n    -- parse copyright\\r\\n    pos, output[\\"Copyright\\"] \\u003d bin.unpack(\\"z\\", response, 142 + offset)\\r\\n\\r\\n    -- for each element in the table, if it is nil, then remove the information from the table\\r\\n    for key,value in pairs(output) do\\r\\n      if(string.len(output[key]) \\u003d\\u003d 0) then\\r\\n        output[key] \\u003d nil\\r\\n      end\\r\\n    end\\r\\n    -- return output\\r\\n    return output\\r\\n  else\\r\\n    output \\u003d DescFlag(S7DescFlag)\\r\\n\\treturn output\\r\\n  end\\r\\nend\\r\\n---\\r\\n--  Function to set the nmap output for the host, if a valid S7COMM packet\\r\\n--  is received then the output will show that the port is open\\r\\n--  and change the output to reflect an S7 PLC\\r\\n--\\r\\n-- @param host Host that was passed in via nmap\\r\\n-- @param port port that S7COMM is running on\\r\\nfunction set_nmap(host, port)\\r\\n  --set port Open\\r\\n  port.state \\u003d \\"open\\"\\r\\n  -- set that detected an Siemens S7\\r\\n  port.version.name \\u003d \\"iso-tsap\\"\\r\\n  port.version.devicetype \\u003d \\"specialized\\"\\r\\n  port.version.product \\u003d \\"Siemens S7 PLC\\"\\r\\n  nmap.set_port_version(host, port)\\r\\n  nmap.set_port_state(host, port, \\"open\\")\\r\\n\\r\\nend\\r\\n---\\r\\n--\\r\\n-- if get fail SZL info output S7 protocol Flag\\r\\n--\\r\\n-- add S7 protocol Flag\\r\\n--\\r\\n---\\r\\n\\r\\nfunction DescFlag(S7DescFlag)\\r\\n  output \\u003d stdnse.output_table()\\r\\n  local pos, protocol_head \\u003d bin.unpack(\\"C\\", S7DescFlag, 1)\\r\\n  if (protocol_head \\u003d\\u003d 0x03) then\\r\\n    output[\\"Devices Type\\"] \\u003d \\u0027Siemens S7 Series Devices\\u0027\\r\\n\\treturn output\\r\\n\\tend\\r\\nend\\r\\n--\\r\\n--\\r\\n---\\r\\n---\\r\\n--  Action Function that is used to run the NSE. This function will send the initial query to the\\r\\n--  host and port that were passed in via nmap. The initial response is parsed to determine if host\\r\\n--  is a S7COMM device. If it is then more actions are taken to gather extra information.\\r\\n--\\r\\n-- @param host Host that was scanned via nmap\\r\\n-- @param port port that was scanned via nmap\\r\\naction \\u003d function(host,port)\\r\\n  -- COTP packet with a dst of 102\\r\\n  local COTP \\u003d bin.pack(\\"H\\",\\"0300001611e00000001400c1020100c2020\\" .. \\"102\\" .. \\"c0010a\\")\\r\\n  -- COTP packet with a dst of 200\\r\\n  local alt_COTP \\u003d bin.pack(\\"H\\",\\"0300001611e00000000500c1020100c2020\\" .. \\"200\\" .. \\"c0010a\\")\\r\\n  -- setup the ROSCTR Packet\\r\\n  local ROSCTR_Setup \\u003d bin.pack(\\"H\\",\\"0300001902f08032010000000000080000f0000001000101e0\\")\\r\\n  -- setup the Read SZL information packet\\r\\n  local Read_SZL \\u003d bin.pack(\\"H\\",\\"0300002102f080320700000000000800080001120411440100ff09000400110001\\")\\r\\n  -- setup the first SZL request (gather the basic hardware and version number)\\r\\n  local first_SZL_Request \\u003d bin.pack(\\"H\\",\\"0300002102f080320700000000000800080001120411440100ff09000400110001\\")\\r\\n  -- setup the second SZL request\\r\\n  local second_SZL_Request \\u003d bin.pack(\\"H\\",\\"0300002102f080320700000000000800080001120411440100ff090004001c0001\\")\\r\\n  ---\\r\\n  -- add S7-1200 packet \\r\\n  -- by Z-0ne   plcscan.org\\r\\n  -- Based on S7COMM Protocol analysis plugin.\\r\\n  --\\r\\n  ---\\r\\n  -- S7-1200 PLC usage Rack 0 Slot 1\\r\\n  local COTP_0x0000 \\u003d bin.pack(\\"H\\",\\"0300001611e00000000100c0010ac1020100c2020301\\")\\r\\n  -- Setup communication 0xf0\\r\\n  local Setup_comm \\u003d bin.pack(\\"H\\",\\"0300001902f080320100000c0000080000f0000001000101e0\\")\\r\\n  -- Request SZL functions Read SZL ID\\u003d0X0011\\r\\n  local Req_SZL_0x0011 \\u003d bin.pack(\\"H\\",\\"0300002102f080320700000d00000800080001120411440100ff09000400110000\\")\\r\\n  -- response is used to collect the packet responses\\r\\n  local response\\r\\n  -- output table for Nmap\\r\\n  local output \\u003d stdnse.output_table()\\r\\n  -- create socket for communications\\r\\n  local sock \\u003d nmap.new_socket()\\r\\n  -- connect to host\\r\\n  local constatus,conerr \\u003d sock:connect(host,port)\\r\\n  if not constatus then\\r\\n    stdnse.print_debug(1,\\r\\n      \\u0027Error establishing connection for %s - %s\\u0027, host,conerr\\r\\n      )\\r\\n    return nil\\r\\n  end\\r\\n  -- send and receive the COTP Packet\\r\\n  S7DescFlag  \\u003d send_receive(sock, COTP)\\r\\n  -- unpack the PDU Type\\r\\n  local pos, CC_connect_confirm \\u003d bin.unpack(\\"C\\", S7DescFlag, 6)\\r\\n  -- if PDU type is not 0xd0, then not a successful COTP connection\\r\\n---\\r\\n--  if ( CC_connect_confirm ~\\u003d 0xd0) then\\r\\n--    return nil\\r\\n--  end\\r\\n---\\r\\n    if ( CC_connect_confirm ~\\u003d 0xd0) then\\r\\n---\\r\\n--   add support S7 1200 packet send\\r\\n---\\r\\n      output \\u003d stdnse.output_table()\\r\\n\\t  local constatus,conerr \\u003d sock:connect(host,port)\\r\\n      if not constatus then\\r\\n        stdnse.print_debug(1,\\r\\n          \\u0027Error establishing connection for %s - %s\\u0027, host,conerr\\r\\n          )\\r\\n        return nil\\r\\n      end\\r\\n      S7DescFlag  \\u003d send_receive(sock, COTP_0x0000)\\r\\n\\t  local pos, CC_connect_confirm \\u003d bin.unpack(\\"C\\", S7DescFlag, 6)\\r\\n\\t  if ( CC_connect_confirm ~\\u003d 0xd0) then\\r\\n\\t    stdnse.print_debug(1, \\"Not a successful COTP Packet_1200\\")\\r\\n\\t\\toutput \\u003d DescFlag(S7DescFlag)\\r\\n\\t\\treturn output\\r\\n\\t  end\\r\\n\\t  response \\u003d send_receive(sock, Setup_comm)\\r\\n\\t  local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n\\t  if ( protocol_id ~\\u003d 0x32) then\\r\\n\\t    stdnse.print_debug(1, \\"Not a successful S7COMM Packet_1200\\")\\r\\n\\t\\toutput \\u003d DescFlag(S7DescFlag)\\r\\n\\t\\treturn output\\r\\n\\t  end\\r\\n\\t  response  \\u003d send_receive(sock, Req_SZL_0x0011)\\r\\n\\t  local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n\\t  if ( protocol_id ~\\u003d 0x32) then\\r\\n\\t    stdnse.print_debug(1, \\"Not a successful S7COMM Packet_1200\\")\\r\\n\\t\\toutput \\u003d DescFlag(S7DescFlag)\\r\\n\\t\\treturn output\\r\\n\\t  end\\r\\n\\t  output \\u003d parse_response(response, host, port, output)\\r\\n\\t  return output\\r\\n--\\r\\n---\\r\\n  end\\r\\n  -- send and receive the ROSCTR Setup Packet\\r\\n  response  \\u003d send_receive(sock, ROSCTR_Setup)\\r\\n  -- unpack the protocol ID\\r\\n  local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n  -- if protocol ID is not 0x32 then return nil\\r\\n---\\r\\n  if ( protocol_id ~\\u003d 0x32) then\\r\\n    stdnse.print_debug(1, \\"Not a successful S7COMM Packet\\")\\r\\n--    return nil\\r\\n end\\r\\n---  \\r\\n  -- send and receive the READ_SZL packet\\r\\n  response  \\u003d send_receive(sock, Read_SZL)\\r\\n  local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n  -- if protocol ID is not 0x32 then return nil\\r\\n---\\r\\n  if ( protocol_id ~\\u003d 0x32) then\\r\\n    stdnse.print_debug(1, \\"Not a successful S7COMM Packet\\")\\r\\n--    return nil\\r\\n  end\\r\\n---\\r\\n  -- send and receive the first SZL Request packet\\r\\n  response  \\u003d send_receive(sock, first_SZL_Request)\\r\\n  -- parse the response for basic hardware information\\r\\n  output \\u003d parse_response(response, host, port, output)\\r\\n  -- send and receive the second SZL Request packet\\r\\n  response \\u003d send_receive(sock, second_SZL_Request)\\r\\n  -- parse the response for more information\\r\\n  output \\u003d second_parse_response(response, output)\\r\\n  -- if nothing was parsed from the previous two responses\\r\\n  if(output \\u003d\\u003d nil) then\\r\\n    -- re initialize the table\\r\\n    output \\u003d stdnse.output_table()\\r\\n    -- re connect to the device ( a RST packet was sent in the previous attempts)\\r\\n    local constatus,conerr \\u003d sock:connect(host,port)\\r\\n    if not constatus then\\r\\n      stdnse.print_debug(1,\\r\\n        \\u0027Error establishing connection for %s - %s\\u0027, host,conerr\\r\\n        )\\r\\n      return nil\\r\\n    end\\r\\n    -- send and receive the alternate COTP Packet, the dst is 200 instead of 102( do nothing with result)\\r\\n    S7DescFlag  \\u003d send_receive(sock, alt_COTP)\\r\\n    local pos, CC_connect_confirm \\u003d bin.unpack(\\"C\\", S7DescFlag, 6)\\r\\n    -- if PDU type is not 0xd0, then not a successful COTP connection\\r\\n---\\r\\n    if ( CC_connect_confirm ~\\u003d 0xd0) then\\r\\n      stdnse.print_debug(1, \\"Not a successful COTP Packet\\")\\r\\n--      return nil\\r\\n    end\\r\\n---\\r\\n    -- send and receive the packets as before.\\r\\n    response  \\u003d send_receive(sock, ROSCTR_Setup)\\r\\n    -- unpack the protocol ID\\r\\n    local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n    -- if protocol ID is not 0x32 then return nil\\r\\n---\\r\\n    if ( protocol_id ~\\u003d 0x32) then\\r\\n      stdnse.print_debug(1, \\"Not a successful S7COMM Packet\\")\\r\\n--      return nil\\r\\n    end\\r\\n---\\r\\n    response  \\u003d send_receive(sock, Read_SZL)\\r\\n    -- unpack the protocol ID\\r\\n    local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n    -- if protocol ID is not 0x32 then return nil\\r\\n---\\r\\n    if ( protocol_id ~\\u003d 0x32) then\\r\\n      stdnse.print_debug(1, \\"Not a successful S7COMM Packet\\")\\r\\n--      return nil\\r\\n    end\\r\\n---\\r\\n    response  \\u003d send_receive(sock, first_SZL_Request)\\r\\n    output \\u003d parse_response(response, host, port, \\"ONE\\", output)\\r\\n    response \\u003d send_receive(sock, second_SZL_Request)\\r\\n    output \\u003d parse_response(response, host, port, \\"TWO\\", output)\\r\\n  end\\r\\n  -- close the socket\\r\\n  sock:close()\\r\\n  \\r\\n  -- If we parsed anything, then set the version info for Nmap\\r\\n  if #output \\u003e 0 then\\r\\n    set_nmap(host, port)\\r\\n  end\\r\\n  -- return output to Nmap\\r\\n  return output\\r\\n\\r\\nend\\r\\n\\r\\n","--\\r\\n-- required packages for this script\\r\\n--\\r\\n\\r\\n-- Fix Support S7-300\xef\xbf\xbd\xef\xbf\xbd400 and S7-1200 and S7 Series Unknown Devices\\r\\n-- Last change 2014-11-14 plcscan.org\\r\\n--\\r\\nlocal bin \\u003d require \\"bin\\"\\r\\nlocal nmap \\u003d require \\"nmap\\"\\r\\nlocal shortport \\u003d require \\"shortport\\"\\r\\nlocal stdnse \\u003d require \\"stdnse\\"\\r\\nlocal string \\u003d require \\"string\\"\\r\\nlocal table \\u003d require \\"table\\"\\r\\n\\r\\ndescription \\u003d [[\\r\\nEnumerates Siemens S7 PLC Devices and collects their device information. This\\r\\nNSE is based off PLCScan that was developed by Positive Research and\\r\\nScadastrangelove (https://code.google.com/p/plcscan/). This script is meant to\\r\\nprovide the same functionality as PLCScan inside of Nmap. Some of the\\r\\ninformation that is collected by PLCScan was not ported over to this NSE, this\\r\\ninformation can be parsed out of the packets that are received.\\r\\n\\r\\nThanks to Positive Research, and Dmitry Efanov for creating PLCScan\\r\\n]]\\r\\n\\r\\nauthor \\u003d \\"Stephen Hilt (Digital Bond)\\"\\r\\nlicense \\u003d \\"Same as Nmap--See http://nmap.org/book/man-legal.html\\"\\r\\ncategories \\u003d {\\"discovery\\",\\"intrusive\\"}\\r\\n\\r\\n---\\r\\n-- @usage\\r\\n-- nmap -sS --script s7-discover.nse -p 102 \\u003chost/s\\u003e\\r\\n--\\r\\n-- @output\\r\\n--102/tcp open  Siemens S7 315 PLC\\r\\n--| s7-discover:\\r\\n--|   Basic Hardware: 6ES7 315-2AG10-0AB0\\r\\n--|   System Name: SIMATIC 300(1)\\r\\n--|   Copyright: Original Siemens Equipment\\r\\n--|   Version: 2.6.9\\r\\n--|   Module Type: CPU 315-2 DP\\r\\n--|   Module: 6ES7 315-2AG10-0AB0\\r\\n--|_  Serial Number: S C-X4U421302009\\r\\n--\\r\\n-- @output\\r\\n--102/tcp open  Siemens S7 1200 PLC\\r\\n-- s7-enumerate:\\r\\n--    Module: 6ES7 214-1AE30-0XB0\\r\\n--    Basic Hardware: 6ES7 214-1AE30-0XB0\\r\\n--    Version: 2.2.0\\r\\n--\\r\\n-- @xmloutput\\r\\n--\\u003celem key\\u003d\\"Basic Hardware\\"\\u003e6ES7 315-2AG10-0AB0\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"System Name\\"\\u003eSIMATIC 300(1)\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Copyright\\"\\u003eOriginal Siemens Equipment\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Version\\"\\u003e2.6.9\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Object Name\\"\\u003eSimpleServer\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Module Type\\"\\u003eCPU 315-2 DP\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Module\\"\\u003e6ES7 315-2AG10-0AB0\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Serial Number\\"\\u003eS C-X4U421302009\\u003c/elem\\u003e\\r\\n--\\u003celm key\\u003d\\"Plant Identification\\"\\u003e\\u003c/elem\\u003e\\r\\n\\r\\n\\r\\n-- port rule for devices running on TCP/102\\r\\nportrule \\u003d shortport.port_or_service(102, \\"iso-tsap\\", \\"tcp\\")\\r\\n\\r\\n---\\r\\n-- Function to send and receive the S7COMM Packet\\r\\n--\\r\\n-- First argument is the socket that was created inside of the main Action\\r\\n-- this will be utilized to send and receive the packets from the host.\\r\\n-- the second argument is the query to be sent, this is passed in and is created\\r\\n-- inside of the main action.\\r\\n-- @param socket the socket that was created in Action.\\r\\n-- @param query the specific query that you want to send/receive on.\\r\\nfunction send_receive(socket, query)\\r\\n  local sendstatus, senderr \\u003d socket:send(query)\\r\\n  if(sendstatus \\u003d\\u003d false) then\\r\\n    return \\"Error Sending S7COMM\\"\\r\\n  end\\r\\n  -- receive response\\r\\n  local rcvstatus,response \\u003d socket:receive()\\r\\n  if(rcvstatus \\u003d\\u003d false) then\\r\\n    return \\"Error Reading S7COMM\\"\\r\\n  end\\r\\n  return response\\r\\nend\\r\\n\\r\\n---\\r\\n-- Function to parse the first SZL Request response that was received from the S7 PLCC\\r\\n--\\r\\n-- First argument is the socket that was created inside of the main Action\\r\\n-- this will be utilized to send and receive the packets from the host.\\r\\n-- the second argument is the query to be sent, this is passed in and is created\\r\\n-- inside of the main action.\\r\\n-- @param response Packet response that was received from S7 host.\\r\\n-- @param host The host hat was passed in via Nmap, this is to change output of host/port\\r\\n-- @param port The port that was passed in via Nmap, this is to change output of host/port\\r\\n-- @param output Table used for output for return to Nmap\\r\\nfunction parse_response(response, host, port, output)\\r\\n  -- unpack the protocol ID\\r\\n  local pos, value \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n  -- unpack the second byte of the SZL-ID\\r\\n  local pos, szl_id \\u003d bin.unpack(\\"C\\", response, 31)\\r\\n  -- set the offset to 0\\r\\n  local offset \\u003d 0\\r\\n  -- if the protocol ID is 0x32\\r\\n  if (value \\u003d\\u003d 0x32) then\\r\\n    local pos\\r\\n    -- unpack the module information\\r\\n    pos, output[\\"Module\\"] \\u003d bin.unpack(\\"z\\", response, 44)\\r\\n    -- unpack the basic hardware information\\r\\n    pos, output[\\"Basic Hardware\\"] \\u003d bin.unpack(\\"z\\", response, 72)\\r\\n    -- set version number to 0\\r\\n    local version \\u003d 0\\r\\n    -- parse version number\\r\\n    local pos, char1,char2,char3 \\u003d bin.unpack(\\"CCC\\", response, 123)\\r\\n    -- concatenate string, or if string is nil make version number 0.0\\r\\n    output[\\"Version\\"] \\u003d table.concat({char1 or \\"0.0\\", char2, char3}, \\".\\")\\r\\n    -- return the output table\\r\\n    return output\\r\\n  else\\r\\n    output \\u003d DescFlag(S7DescFlag)\\r\\n\\treturn output\\r\\n  end\\r\\nend\\r\\n\\r\\n---\\r\\n-- Function to parse the second SZL Request response that was received from the S7 PLC\\r\\n--\\r\\n-- First argument is the socket that was created inside of the main Action\\r\\n-- this will be utilized to send and receive the packets from the host.\\r\\n-- the second argument is the query to be sent, this is passed in and is created\\r\\n-- inside of the main action.\\r\\n-- @param response Packet response that was received from S7 host.\\r\\n-- @param output Table used for output for return to Nmap\\r\\nfunction second_parse_response(response, output)\\r\\n  local offset \\u003d 0\\r\\n  -- unpack the protocol ID\\r\\n  local pos, value \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n  -- unpack the second byte of the SZL-ID\\r\\n  local pos, szl_id \\u003d bin.unpack(\\"C\\", response, 31)\\r\\n  -- if the protocol ID is 0x32\\r\\n  if (value \\u003d\\u003d 0x32) then\\r\\n    -- if the szl-ID is not 0x1c\\r\\n    if( szl_id ~\\u003d 0x1c ) then\\r\\n      -- change offset to 4, this is where most ov valid PLCs will fall\\r\\n      offset \\u003d 4\\r\\n    end\\r\\n    -- parse system name\\r\\n    pos, output[\\"System Name\\"] \\u003d bin.unpack(\\"z\\", response, 40 + offset)\\r\\n    -- parse module type\\r\\n    pos, output[\\"Module Type\\"] \\u003d bin.unpack(\\"z\\", response, 74 + offset)\\r\\n    -- parse serial number\\r\\n    pos, output[\\"Serial Number\\"] \\u003d bin.unpack(\\"z\\", response, 176 + offset)\\r\\n    -- parse plant identification\\r\\n    pos, output[\\"Plant Identification\\"] \\u003d bin.unpack(\\"z\\", response, 108 + offset)\\r\\n    -- parse copyright\\r\\n    pos, output[\\"Copyright\\"] \\u003d bin.unpack(\\"z\\", response, 142 + offset)\\r\\n\\r\\n    -- for each element in the table, if it is nil, then remove the information from the table\\r\\n    for key,value in pairs(output) do\\r\\n      if(string.len(output[key]) \\u003d\\u003d 0) then\\r\\n        output[key] \\u003d nil\\r\\n      end\\r\\n    end\\r\\n    -- return output\\r\\n    return output\\r\\n  else\\r\\n    output \\u003d DescFlag(S7DescFlag)\\r\\n\\treturn output\\r\\n  end\\r\\nend\\r\\n---\\r\\n--  Function to set the nmap output for the host, if a valid S7COMM packet\\r\\n--  is received then the output will show that the port is open\\r\\n--  and change the output to reflect an S7 PLC\\r\\n--\\r\\n-- @param host Host that was passed in via nmap\\r\\n-- @param port port that S7COMM is running on\\r\\nfunction set_nmap(host, port)\\r\\n  --set port Open\\r\\n  port.state \\u003d \\"open\\"\\r\\n  -- set that detected an Siemens S7\\r\\n  port.version.name \\u003d \\"iso-tsap\\"\\r\\n  port.version.devicetype \\u003d \\"specialized\\"\\r\\n  port.version.product \\u003d \\"Siemens S7 PLC\\"\\r\\n  nmap.set_port_version(host, port)\\r\\n  nmap.set_port_state(host, port, \\"open\\")\\r\\n\\r\\nend\\r\\n---\\r\\n--\\r\\n-- if get fail SZL info output S7 protocol Flag\\r\\n--\\r\\n-- add S7 protocol Flag\\r\\n--\\r\\n---\\r\\n\\r\\nfunction DescFlag(S7DescFlag)\\r\\n  output \\u003d stdnse.output_table()\\r\\n  local pos, protocol_head \\u003d bin.unpack(\\"C\\", S7DescFlag, 1)\\r\\n  if (protocol_head \\u003d\\u003d 0x03) then\\r\\n    output[\\"Devices Type\\"] \\u003d \\u0027Siemens S7 Series Devices\\u0027\\r\\n\\treturn output\\r\\n\\tend\\r\\nend\\r\\n--\\r\\n--\\r\\n---\\r\\n---\\r\\n--  Action Function that is used to run the NSE. This function will send the initial query to the\\r\\n--  host and port that were passed in via nmap. The initial response is parsed to determine if host\\r\\n--  is a S7COMM device. If it is then more actions are taken to gather extra information.\\r\\n--\\r\\n-- @param host Host that was scanned via nmap\\r\\n-- @param port port that was scanned via nmap\\r\\naction \\u003d function(host,port)\\r\\n  -- COTP packet with a dst of 102\\r\\n  local COTP \\u003d bin.pack(\\"H\\",\\"0300001611e00000001400c1020100c2020\\" .. \\"102\\" .. \\"c0010a\\")\\r\\n  -- COTP packet with a dst of 200\\r\\n  local alt_COTP \\u003d bin.pack(\\"H\\",\\"0300001611e00000000500c1020100c2020\\" .. \\"200\\" .. \\"c0010a\\")\\r\\n  -- setup the ROSCTR Packet\\r\\n  local ROSCTR_Setup \\u003d bin.pack(\\"H\\",\\"0300001902f08032010000000000080000f0000001000101e0\\")\\r\\n  -- setup the Read SZL information packet\\r\\n  local Read_SZL \\u003d bin.pack(\\"H\\",\\"0300002102f080320700000000000800080001120411440100ff09000400110001\\")\\r\\n  -- setup the first SZL request (gather the basic hardware and version number)\\r\\n  local first_SZL_Request \\u003d bin.pack(\\"H\\",\\"0300002102f080320700000000000800080001120411440100ff09000400110001\\")\\r\\n  -- setup the second SZL request\\r\\n  local second_SZL_Request \\u003d bin.pack(\\"H\\",\\"0300002102f080320700000000000800080001120411440100ff090004001c0001\\")\\r\\n  ---\\r\\n  -- add S7-1200 packet \\r\\n  -- by Z-0ne   plcscan.org\\r\\n  -- Based on S7COMM Protocol analysis plugin.\\r\\n  --\\r\\n  ---\\r\\n  -- S7-1200 PLC usage Rack 0 Slot 1\\r\\n  local COTP_0x0000 \\u003d bin.pack(\\"H\\",\\"0300001611e00000000100c0010ac1020100c2020301\\")\\r\\n  -- Setup communication 0xf0\\r\\n  local Setup_comm \\u003d bin.pack(\\"H\\",\\"0300001902f080320100000c0000080000f0000001000101e0\\")\\r\\n  -- Request SZL functions Read SZL ID\\u003d0X0011\\r\\n  local Req_SZL_0x0011 \\u003d bin.pack(\\"H\\",\\"0300002102f080320700000d00000800080001120411440100ff09000400110000\\")\\r\\n  -- response is used to collect the packet responses\\r\\n  local response\\r\\n  -- output table for Nmap\\r\\n  local output \\u003d stdnse.output_table()\\r\\n  -- create socket for communications\\r\\n  local sock \\u003d nmap.new_socket()\\r\\n  -- connect to host\\r\\n  local constatus,conerr \\u003d sock:connect(host,port)\\r\\n  if not constatus then\\r\\n    stdnse.print_debug(1,\\r\\n      \\u0027Error establishing connection for %s - %s\\u0027, host,conerr\\r\\n      )\\r\\n    return nil\\r\\n  end\\r\\n  -- send and receive the COTP Packet\\r\\n  S7DescFlag  \\u003d send_receive(sock, COTP)\\r\\n  -- unpack the PDU Type\\r\\n  local pos, CC_connect_confirm \\u003d bin.unpack(\\"C\\", S7DescFlag, 6)\\r\\n  -- if PDU type is not 0xd0, then not a successful COTP connection\\r\\n---\\r\\n--  if ( CC_connect_confirm ~\\u003d 0xd0) then\\r\\n--    return nil\\r\\n--  end\\r\\n---\\r\\n    if ( CC_connect_confirm ~\\u003d 0xd0) then\\r\\n---\\r\\n--   add support S7 1200 packet send\\r\\n---\\r\\n      output \\u003d stdnse.output_table()\\r\\n\\t  local constatus,conerr \\u003d sock:connect(host,port)\\r\\n      if not constatus then\\r\\n        stdnse.print_debug(1,\\r\\n          \\u0027Error establishing connection for %s - %s\\u0027, host,conerr\\r\\n          )\\r\\n        return nil\\r\\n      end\\r\\n      S7DescFlag  \\u003d send_receive(sock, COTP_0x0000)\\r\\n\\t  local pos, CC_connect_confirm \\u003d bin.unpack(\\"C\\", S7DescFlag, 6)\\r\\n\\t  if ( CC_connect_confirm ~\\u003d 0xd0) then\\r\\n\\t    stdnse.print_debug(1, \\"Not a successful COTP Packet_1200\\")\\r\\n\\t\\toutput \\u003d DescFlag(S7DescFlag)\\r\\n\\t\\treturn output\\r\\n\\t  end\\r\\n\\t  response \\u003d send_receive(sock, Setup_comm)\\r\\n\\t  local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n\\t  if ( protocol_id ~\\u003d 0x32) then\\r\\n\\t    stdnse.print_debug(1, \\"Not a successful S7COMM Packet_1200\\")\\r\\n\\t\\toutput \\u003d DescFlag(S7DescFlag)\\r\\n\\t\\treturn output\\r\\n\\t  end\\r\\n\\t  response  \\u003d send_receive(sock, Req_SZL_0x0011)\\r\\n\\t  local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n\\t  if ( protocol_id ~\\u003d 0x32) then\\r\\n\\t    stdnse.print_debug(1, \\"Not a successful S7COMM Packet_1200\\")\\r\\n\\t\\toutput \\u003d DescFlag(S7DescFlag)\\r\\n\\t\\treturn output\\r\\n\\t  end\\r\\n\\t  output \\u003d parse_response(response, host, port, output)\\r\\n\\t  return output\\r\\n--\\r\\n---\\r\\n  end\\r\\n  -- send and receive the ROSCTR Setup Packet\\r\\n  response  \\u003d send_receive(sock, ROSCTR_Setup)\\r\\n  -- unpack the protocol ID\\r\\n  local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n  -- if protocol ID is not 0x32 then return nil\\r\\n---\\r\\n  if ( protocol_id ~\\u003d 0x32) then\\r\\n    stdnse.print_debug(1, \\"Not a successful S7COMM Packet\\")\\r\\n--    return nil\\r\\n end\\r\\n---  \\r\\n  -- send and receive the READ_SZL packet\\r\\n  response  \\u003d send_receive(sock, Read_SZL)\\r\\n  local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n  -- if protocol ID is not 0x32 then return nil\\r\\n---\\r\\n  if ( protocol_id ~\\u003d 0x32) then\\r\\n    stdnse.print_debug(1, \\"Not a successful S7COMM Packet\\")\\r\\n--    return nil\\r\\n  end\\r\\n---\\r\\n  -- send and receive the first SZL Request packet\\r\\n  response  \\u003d send_receive(sock, first_SZL_Request)\\r\\n  -- parse the response for basic hardware information\\r\\n  output \\u003d parse_response(response, host, port, output)\\r\\n  -- send and receive the second SZL Request packet\\r\\n  response \\u003d send_receive(sock, second_SZL_Request)\\r\\n  -- parse the response for more information\\r\\n  output \\u003d second_parse_response(response, output)\\r\\n  -- if nothing was parsed from the previous two responses\\r\\n  if(output \\u003d\\u003d nil) then\\r\\n    -- re initialize the table\\r\\n    output \\u003d stdnse.output_table()\\r\\n    -- re connect to the device ( a RST packet was sent in the previous attempts)\\r\\n    local constatus,conerr \\u003d sock:connect(host,port)\\r\\n    if not constatus then\\r\\n      stdnse.print_debug(1,\\r\\n        \\u0027Error establishing connection for %s - %s\\u0027, host,conerr\\r\\n        )\\r\\n      return nil\\r\\n    end\\r\\n    -- send and receive the alternate COTP Packet, the dst is 200 instead of 102( do nothing with result)\\r\\n    S7DescFlag  \\u003d send_receive(sock, alt_COTP)\\r\\n    local pos, CC_connect_confirm \\u003d bin.unpack(\\"C\\", S7DescFlag, 6)\\r\\n    -- if PDU type is not 0xd0, then not a successful COTP connection\\r\\n---\\r\\n    if ( CC_connect_confirm ~\\u003d 0xd0) then\\r\\n      stdnse.print_debug(1, \\"Not a successful COTP Packet\\")\\r\\n--      return nil\\r\\n    end\\r\\n---\\r\\n    -- send and receive the packets as before.\\r\\n    response  \\u003d send_receive(sock, ROSCTR_Setup)\\r\\n    -- unpack the protocol ID\\r\\n    local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n    -- if protocol ID is not 0x32 then return nil\\r\\n---\\r\\n    if ( protocol_id ~\\u003d 0x32) then\\r\\n      stdnse.print_debug(1, \\"Not a successful S7COMM Packet\\")\\r\\n--      return nil\\r\\n    end\\r\\n---\\r\\n    response  \\u003d send_receive(sock, Read_SZL)\\r\\n    -- unpack the protocol ID\\r\\n    local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n    -- if protocol ID is not 0x32 then return nil\\r\\n---\\r\\n    if ( protocol_id ~\\u003d 0x32) then\\r\\n      stdnse.print_debug(1, \\"Not a successful S7COMM Packet\\")\\r\\n--      return nil\\r\\n    end\\r\\n---\\r\\n    response  \\u003d send_receive(sock, first_SZL_Request)\\r\\n    output \\u003d parse_response(response, host, port, \\"ONE\\", output)\\r\\n    response \\u003d send_receive(sock, second_SZL_Request)\\r\\n    output \\u003d parse_response(response, host, port, \\"TWO\\", output)\\r\\n  end\\r\\n  -- close the socket\\r\\n  sock:close()\\r\\n  \\r\\n  -- If we parsed anything, then set the version info for Nmap\\r\\n  if #output \\u003e 0 then\\r\\n    set_nmap(host, port)\\r\\n  end\\r\\n  -- return output to Nmap\\r\\n  return output\\r\\n\\r\\nend\\r\\n\\r\\n","--\\r\\n-- required packages for this script\\r\\n--\\r\\n\\r\\n-- Fix Support S7-300\xef\xbf\xbd\xef\xbf\xbd400 and S7-1200 and S7 Series Unknown Devices\\r\\n-- Last change 2014-11-14 plcscan.org\\r\\n--\\r\\nlocal bin \\u003d require \\"bin\\"\\r\\nlocal nmap \\u003d require \\"nmap\\"\\r\\nlocal shortport \\u003d require \\"shortport\\"\\r\\nlocal stdnse \\u003d require \\"stdnse\\"\\r\\nlocal string \\u003d require \\"string\\"\\r\\nlocal table \\u003d require \\"table\\"\\r\\n\\r\\ndescription \\u003d [[\\r\\nEnumerates Siemens S7 PLC Devices and collects their device information. This\\r\\nNSE is based off PLCScan that was developed by Positive Research and\\r\\nScadastrangelove (https://code.google.com/p/plcscan/). This script is meant to\\r\\nprovide the same functionality as PLCScan inside of Nmap. Some of the\\r\\ninformation that is collected by PLCScan was not ported over to this NSE, this\\r\\ninformation can be parsed out of the packets that are received.\\r\\n\\r\\nThanks to Positive Research, and Dmitry Efanov for creating PLCScan\\r\\n]]\\r\\n\\r\\nauthor \\u003d \\"Stephen Hilt (Digital Bond)\\"\\r\\nlicense \\u003d \\"Same as Nmap--See http://nmap.org/book/man-legal.html\\"\\r\\ncategories \\u003d {\\"discovery\\",\\"intrusive\\"}\\r\\n\\r\\n---\\r\\n-- @usage\\r\\n-- nmap -sS --script s7-discover.nse -p 102 \\u003chost/s\\u003e\\r\\n--\\r\\n-- @output\\r\\n--102/tcp open  Siemens S7 315 PLC\\r\\n--| s7-discover:\\r\\n--|   Basic Hardware: 6ES7 315-2AG10-0AB0\\r\\n--|   System Name: SIMATIC 300(1)\\r\\n--|   Copyright: Original Siemens Equipment\\r\\n--|   Version: 2.6.9\\r\\n--|   Module Type: CPU 315-2 DP\\r\\n--|   Module: 6ES7 315-2AG10-0AB0\\r\\n--|_  Serial Number: S C-X4U421302009\\r\\n--\\r\\n-- @output\\r\\n--102/tcp open  Siemens S7 1200 PLC\\r\\n-- s7-enumerate:\\r\\n--    Module: 6ES7 214-1AE30-0XB0\\r\\n--    Basic Hardware: 6ES7 214-1AE30-0XB0\\r\\n--    Version: 2.2.0\\r\\n--\\r\\n-- @xmloutput\\r\\n--\\u003celem key\\u003d\\"Basic Hardware\\"\\u003e6ES7 315-2AG10-0AB0\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"System Name\\"\\u003eSIMATIC 300(1)\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Copyright\\"\\u003eOriginal Siemens Equipment\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Version\\"\\u003e2.6.9\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Object Name\\"\\u003eSimpleServer\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Module Type\\"\\u003eCPU 315-2 DP\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Module\\"\\u003e6ES7 315-2AG10-0AB0\\u003c/elem\\u003e\\r\\n--\\u003celem key\\u003d\\"Serial Number\\"\\u003eS C-X4U421302009\\u003c/elem\\u003e\\r\\n--\\u003celm key\\u003d\\"Plant Identification\\"\\u003e\\u003c/elem\\u003e\\r\\n\\r\\n\\r\\n-- port rule for devices running on TCP/102\\r\\nportrule \\u003d shortport.port_or_service(102, \\"iso-tsap\\", \\"tcp\\")\\r\\n\\r\\n---\\r\\n-- Function to send and receive the S7COMM Packet\\r\\n--\\r\\n-- First argument is the socket that was created inside of the main Action\\r\\n-- this will be utilized to send and receive the packets from the host.\\r\\n-- the second argument is the query to be sent, this is passed in and is created\\r\\n-- inside of the main action.\\r\\n-- @param socket the socket that was created in Action.\\r\\n-- @param query the specific query that you want to send/receive on.\\r\\nfunction send_receive(socket, query)\\r\\n  local sendstatus, senderr \\u003d socket:send(query)\\r\\n  if(sendstatus \\u003d\\u003d false) then\\r\\n    return \\"Error Sending S7COMM\\"\\r\\n  end\\r\\n  -- receive response\\r\\n  local rcvstatus,response \\u003d socket:receive()\\r\\n  if(rcvstatus \\u003d\\u003d false) then\\r\\n    return \\"Error Reading S7COMM\\"\\r\\n  end\\r\\n  return response\\r\\nend\\r\\n\\r\\n---\\r\\n-- Function to parse the first SZL Request response that was received from the S7 PLCC\\r\\n--\\r\\n-- First argument is the socket that was created inside of the main Action\\r\\n-- this will be utilized to send and receive the packets from the host.\\r\\n-- the second argument is the query to be sent, this is passed in and is created\\r\\n-- inside of the main action.\\r\\n-- @param response Packet response that was received from S7 host.\\r\\n-- @param host The host hat was passed in via Nmap, this is to change output of host/port\\r\\n-- @param port The port that was passed in via Nmap, this is to change output of host/port\\r\\n-- @param output Table used for output for return to Nmap\\r\\nfunction parse_response(response, host, port, output)\\r\\n  -- unpack the protocol ID\\r\\n  local pos, value \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n  -- unpack the second byte of the SZL-ID\\r\\n  local pos, szl_id \\u003d bin.unpack(\\"C\\", response, 31)\\r\\n  -- set the offset to 0\\r\\n  local offset \\u003d 0\\r\\n  -- if the protocol ID is 0x32\\r\\n  if (value \\u003d\\u003d 0x32) then\\r\\n    local pos\\r\\n    -- unpack the module information\\r\\n    pos, output[\\"Module\\"] \\u003d bin.unpack(\\"z\\", response, 44)\\r\\n    -- unpack the basic hardware information\\r\\n    pos, output[\\"Basic Hardware\\"] \\u003d bin.unpack(\\"z\\", response, 72)\\r\\n    -- set version number to 0\\r\\n    local version \\u003d 0\\r\\n    -- parse version number\\r\\n    local pos, char1,char2,char3 \\u003d bin.unpack(\\"CCC\\", response, 123)\\r\\n    -- concatenate string, or if string is nil make version number 0.0\\r\\n    output[\\"Version\\"] \\u003d table.concat({char1 or \\"0.0\\", char2, char3}, \\".\\")\\r\\n    -- return the output table\\r\\n    return output\\r\\n  else\\r\\n    output \\u003d DescFlag(S7DescFlag)\\r\\n\\treturn output\\r\\n  end\\r\\nend\\r\\n\\r\\n---\\r\\n-- Function to parse the second SZL Request response that was received from the S7 PLC\\r\\n--\\r\\n-- First argument is the socket that was created inside of the main Action\\r\\n-- this will be utilized to send and receive the packets from the host.\\r\\n-- the second argument is the query to be sent, this is passed in and is created\\r\\n-- inside of the main action.\\r\\n-- @param response Packet response that was received from S7 host.\\r\\n-- @param output Table used for output for return to Nmap\\r\\nfunction second_parse_response(response, output)\\r\\n  local offset \\u003d 0\\r\\n  -- unpack the protocol ID\\r\\n  local pos, value \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n  -- unpack the second byte of the SZL-ID\\r\\n  local pos, szl_id \\u003d bin.unpack(\\"C\\", response, 31)\\r\\n  -- if the protocol ID is 0x32\\r\\n  if (value \\u003d\\u003d 0x32) then\\r\\n    -- if the szl-ID is not 0x1c\\r\\n    if( szl_id ~\\u003d 0x1c ) then\\r\\n      -- change offset to 4, this is where most ov valid PLCs will fall\\r\\n      offset \\u003d 4\\r\\n    end\\r\\n    -- parse system name\\r\\n    pos, output[\\"System Name\\"] \\u003d bin.unpack(\\"z\\", response, 40 + offset)\\r\\n    -- parse module type\\r\\n    pos, output[\\"Module Type\\"] \\u003d bin.unpack(\\"z\\", response, 74 + offset)\\r\\n    -- parse serial number\\r\\n    pos, output[\\"Serial Number\\"] \\u003d bin.unpack(\\"z\\", response, 176 + offset)\\r\\n    -- parse plant identification\\r\\n    pos, output[\\"Plant Identification\\"] \\u003d bin.unpack(\\"z\\", response, 108 + offset)\\r\\n    -- parse copyright\\r\\n    pos, output[\\"Copyright\\"] \\u003d bin.unpack(\\"z\\", response, 142 + offset)\\r\\n\\r\\n    -- for each element in the table, if it is nil, then remove the information from the table\\r\\n    for key,value in pairs(output) do\\r\\n      if(string.len(output[key]) \\u003d\\u003d 0) then\\r\\n        output[key] \\u003d nil\\r\\n      end\\r\\n    end\\r\\n    -- return output\\r\\n    return output\\r\\n  else\\r\\n    output \\u003d DescFlag(S7DescFlag)\\r\\n\\treturn output\\r\\n  end\\r\\nend\\r\\n---\\r\\n--  Function to set the nmap output for the host, if a valid S7COMM packet\\r\\n--  is received then the output will show that the port is open\\r\\n--  and change the output to reflect an S7 PLC\\r\\n--\\r\\n-- @param host Host that was passed in via nmap\\r\\n-- @param port port that S7COMM is running on\\r\\nfunction set_nmap(host, port)\\r\\n  --set port Open\\r\\n  port.state \\u003d \\"open\\"\\r\\n  -- set that detected an Siemens S7\\r\\n  port.version.name \\u003d \\"iso-tsap\\"\\r\\n  port.version.devicetype \\u003d \\"specialized\\"\\r\\n  port.version.product \\u003d \\"Siemens S7 PLC\\"\\r\\n  nmap.set_port_version(host, port)\\r\\n  nmap.set_port_state(host, port, \\"open\\")\\r\\n\\r\\nend\\r\\n---\\r\\n--\\r\\n-- if get fail SZL info output S7 protocol Flag\\r\\n--\\r\\n-- add S7 protocol Flag\\r\\n--\\r\\n---\\r\\n\\r\\nfunction DescFlag(S7DescFlag)\\r\\n  output \\u003d stdnse.output_table()\\r\\n  local pos, protocol_head \\u003d bin.unpack(\\"C\\", S7DescFlag, 1)\\r\\n  if (protocol_head \\u003d\\u003d 0x03) then\\r\\n    output[\\"Devices Type\\"] \\u003d \\u0027Siemens S7 Series Devices\\u0027\\r\\n\\treturn output\\r\\n\\tend\\r\\nend\\r\\n--\\r\\n--\\r\\n---\\r\\n---\\r\\n--  Action Function that is used to run the NSE. This function will send the initial query to the\\r\\n--  host and port that were passed in via nmap. The initial response is parsed to determine if host\\r\\n--  is a S7COMM device. If it is then more actions are taken to gather extra information.\\r\\n--\\r\\n-- @param host Host that was scanned via nmap\\r\\n-- @param port port that was scanned via nmap\\r\\naction \\u003d function(host,port)\\r\\n  -- COTP packet with a dst of 102\\r\\n  local COTP \\u003d bin.pack(\\"H\\",\\"0300001611e00000001400c1020100c2020\\" .. \\"102\\" .. \\"c0010a\\")\\r\\n  -- COTP packet with a dst of 200\\r\\n  local alt_COTP \\u003d bin.pack(\\"H\\",\\"0300001611e00000000500c1020100c2020\\" .. \\"200\\" .. \\"c0010a\\")\\r\\n  -- setup the ROSCTR Packet\\r\\n  local ROSCTR_Setup \\u003d bin.pack(\\"H\\",\\"0300001902f08032010000000000080000f0000001000101e0\\")\\r\\n  -- setup the Read SZL information packet\\r\\n  local Read_SZL \\u003d bin.pack(\\"H\\",\\"0300002102f080320700000000000800080001120411440100ff09000400110001\\")\\r\\n  -- setup the first SZL request (gather the basic hardware and version number)\\r\\n  local first_SZL_Request \\u003d bin.pack(\\"H\\",\\"0300002102f080320700000000000800080001120411440100ff09000400110001\\")\\r\\n  -- setup the second SZL request\\r\\n  local second_SZL_Request \\u003d bin.pack(\\"H\\",\\"0300002102f080320700000000000800080001120411440100ff090004001c0001\\")\\r\\n  ---\\r\\n  -- add S7-1200 packet \\r\\n  -- by Z-0ne   plcscan.org\\r\\n  -- Based on S7COMM Protocol analysis plugin.\\r\\n  --\\r\\n  ---\\r\\n  -- S7-1200 PLC usage Rack 0 Slot 1\\r\\n  local COTP_0x0000 \\u003d bin.pack(\\"H\\",\\"0300001611e00000000100c0010ac1020100c2020301\\")\\r\\n  -- Setup communication 0xf0\\r\\n  local Setup_comm \\u003d bin.pack(\\"H\\",\\"0300001902f080320100000c0000080000f0000001000101e0\\")\\r\\n  -- Request SZL functions Read SZL ID\\u003d0X0011\\r\\n  local Req_SZL_0x0011 \\u003d bin.pack(\\"H\\",\\"0300002102f080320700000d00000800080001120411440100ff09000400110000\\")\\r\\n  -- response is used to collect the packet responses\\r\\n  local response\\r\\n  -- output table for Nmap\\r\\n  local output \\u003d stdnse.output_table()\\r\\n  -- create socket for communications\\r\\n  local sock \\u003d nmap.new_socket()\\r\\n  -- connect to host\\r\\n  local constatus,conerr \\u003d sock:connect(host,port)\\r\\n  if not constatus then\\r\\n    stdnse.print_debug(1,\\r\\n      \\u0027Error establishing connection for %s - %s\\u0027, host,conerr\\r\\n      )\\r\\n    return nil\\r\\n  end\\r\\n  -- send and receive the COTP Packet\\r\\n  S7DescFlag  \\u003d send_receive(sock, COTP)\\r\\n  -- unpack the PDU Type\\r\\n  local pos, CC_connect_confirm \\u003d bin.unpack(\\"C\\", S7DescFlag, 6)\\r\\n  -- if PDU type is not 0xd0, then not a successful COTP connection\\r\\n---\\r\\n--  if ( CC_connect_confirm ~\\u003d 0xd0) then\\r\\n--    return nil\\r\\n--  end\\r\\n---\\r\\n    if ( CC_connect_confirm ~\\u003d 0xd0) then\\r\\n---\\r\\n--   add support S7 1200 packet send\\r\\n---\\r\\n      output \\u003d stdnse.output_table()\\r\\n\\t  local constatus,conerr \\u003d sock:connect(host,port)\\r\\n      if not constatus then\\r\\n        stdnse.print_debug(1,\\r\\n          \\u0027Error establishing connection for %s - %s\\u0027, host,conerr\\r\\n          )\\r\\n        return nil\\r\\n      end\\r\\n      S7DescFlag  \\u003d send_receive(sock, COTP_0x0000)\\r\\n\\t  local pos, CC_connect_confirm \\u003d bin.unpack(\\"C\\", S7DescFlag, 6)\\r\\n\\t  if ( CC_connect_confirm ~\\u003d 0xd0) then\\r\\n\\t    stdnse.print_debug(1, \\"Not a successful COTP Packet_1200\\")\\r\\n\\t\\toutput \\u003d DescFlag(S7DescFlag)\\r\\n\\t\\treturn output\\r\\n\\t  end\\r\\n\\t  response \\u003d send_receive(sock, Setup_comm)\\r\\n\\t  local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n\\t  if ( protocol_id ~\\u003d 0x32) then\\r\\n\\t    stdnse.print_debug(1, \\"Not a successful S7COMM Packet_1200\\")\\r\\n\\t\\toutput \\u003d DescFlag(S7DescFlag)\\r\\n\\t\\treturn output\\r\\n\\t  end\\r\\n\\t  response  \\u003d send_receive(sock, Req_SZL_0x0011)\\r\\n\\t  local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n\\t  if ( protocol_id ~\\u003d 0x32) then\\r\\n\\t    stdnse.print_debug(1, \\"Not a successful S7COMM Packet_1200\\")\\r\\n\\t\\toutput \\u003d DescFlag(S7DescFlag)\\r\\n\\t\\treturn output\\r\\n\\t  end\\r\\n\\t  output \\u003d parse_response(response, host, port, output)\\r\\n\\t  return output\\r\\n--\\r\\n---\\r\\n  end\\r\\n  -- send and receive the ROSCTR Setup Packet\\r\\n  response  \\u003d send_receive(sock, ROSCTR_Setup)\\r\\n  -- unpack the protocol ID\\r\\n  local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n  -- if protocol ID is not 0x32 then return nil\\r\\n---\\r\\n  if ( protocol_id ~\\u003d 0x32) then\\r\\n    stdnse.print_debug(1, \\"Not a successful S7COMM Packet\\")\\r\\n--    return nil\\r\\n end\\r\\n---  \\r\\n  -- send and receive the READ_SZL packet\\r\\n  response  \\u003d send_receive(sock, Read_SZL)\\r\\n  local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n  -- if protocol ID is not 0x32 then return nil\\r\\n---\\r\\n  if ( protocol_id ~\\u003d 0x32) then\\r\\n    stdnse.print_debug(1, \\"Not a successful S7COMM Packet\\")\\r\\n--    return nil\\r\\n  end\\r\\n---\\r\\n  -- send and receive the first SZL Request packet\\r\\n  response  \\u003d send_receive(sock, first_SZL_Request)\\r\\n  -- parse the response for basic hardware information\\r\\n  output \\u003d parse_response(response, host, port, output)\\r\\n  -- send and receive the second SZL Request packet\\r\\n  response \\u003d send_receive(sock, second_SZL_Request)\\r\\n  -- parse the response for more information\\r\\n  output \\u003d second_parse_response(response, output)\\r\\n  -- if nothing was parsed from the previous two responses\\r\\n  if(output \\u003d\\u003d nil) then\\r\\n    -- re initialize the table\\r\\n    output \\u003d stdnse.output_table()\\r\\n    -- re connect to the device ( a RST packet was sent in the previous attempts)\\r\\n    local constatus,conerr \\u003d sock:connect(host,port)\\r\\n    if not constatus then\\r\\n      stdnse.print_debug(1,\\r\\n        \\u0027Error establishing connection for %s - %s\\u0027, host,conerr\\r\\n        )\\r\\n      return nil\\r\\n    end\\r\\n    -- send and receive the alternate COTP Packet, the dst is 200 instead of 102( do nothing with result)\\r\\n    S7DescFlag  \\u003d send_receive(sock, alt_COTP)\\r\\n    local pos, CC_connect_confirm \\u003d bin.unpack(\\"C\\", S7DescFlag, 6)\\r\\n    -- if PDU type is not 0xd0, then not a successful COTP connection\\r\\n---\\r\\n    if ( CC_connect_confirm ~\\u003d 0xd0) then\\r\\n      stdnse.print_debug(1, \\"Not a successful COTP Packet\\")\\r\\n--      return nil\\r\\n    end\\r\\n---\\r\\n    -- send and receive the packets as before.\\r\\n    response  \\u003d send_receive(sock, ROSCTR_Setup)\\r\\n    -- unpack the protocol ID\\r\\n    local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n    -- if protocol ID is not 0x32 then return nil\\r\\n---\\r\\n    if ( protocol_id ~\\u003d 0x32) then\\r\\n      stdnse.print_debug(1, \\"Not a successful S7COMM Packet\\")\\r\\n--      return nil\\r\\n    end\\r\\n---\\r\\n    response  \\u003d send_receive(sock, Read_SZL)\\r\\n    -- unpack the protocol ID\\r\\n    local pos, protocol_id \\u003d bin.unpack(\\"C\\", response, 8)\\r\\n    -- if protocol ID is not 0x32 then return nil\\r\\n---\\r\\n    if ( protocol_id ~\\u003d 0x32) then\\r\\n      stdnse.print_debug(1, \\"Not a successful S7COMM Packet\\")\\r\\n--      return nil\\r\\n    end\\r\\n---\\r\\n    response  \\u003d send_receive(sock, first_SZL_Request)\\r\\n    output \\u003d parse_response(response, host, port, \\"ONE\\", output)\\r\\n    response \\u003d send_receive(sock, second_SZL_Request)\\r\\n    output \\u003d parse_response(response, host, port, \\"TWO\\", output)\\r\\n  end\\r\\n  -- close the socket\\r\\n  sock:close()\\r\\n  \\r\\n  -- If we parsed anything, then set the version info for Nmap\\r\\n  if #output \\u003e 0 then\\r\\n    set_nmap(host, port)\\r\\n  end\\r\\n  -- return output to Nmap\\r\\n  return output\\r\\n\\r\\nend\\r\\n\\r\\n"]'

def create_scrite(script):
    with open("D:/protocalName.nse",'w',encoding="UTF-8") as fw:
        fw.write(script)
    print("DONE")


if __name__ == '__main__':
    create_scrite(eval(script.decode())[0])
